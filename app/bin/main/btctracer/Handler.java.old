package btctracer;

import java.util.ArrayList;

public class Handler {
  private String rootAddress;
  private Wallet root;
  private ArrayList<ArrayList<Transi>> outTransactions;
  private ArrayList<ArrayList<Wallet>> wallets;
  private int depth;

  public Handler(String rootAddress, int depth) {
    this.rootAddress = rootAddress;
    this.depth = depth;
    root = new Wallet(rootAddress);
    outTransactions = new ArrayList<ArrayList<Transi>>();
    wallets = new ArrayList<ArrayList<Wallet>>();
    wallets.add(new ArrayList<Wallet>());
    wallets.get(0).add(root);

    // inital run
    loadOutgoingTx(root);
    flagAllCoins(0);

    for (Transi t : outTransactions.get(0)) {
      loadWallets(t);
    }

    for (int i = 0; i < depth; i++) {
      for (Wallet w : wallets.get(i)) {
        loadOutgoingTx(w);
        
      }
    }

  }

  private void loadOutgoingTx(Wallet w) {
    String walletAddress = w.getAddress();
    try {
      AddressJSON[] aj = DataRetriever.getAddressJSONObject(walletAddress);
      ArrayList<Transi> tt = new ArrayList<Transi>();

      for (int i = 0; i < aj.length; i++) {
        if (aj[i].getSpentTxid().matches("[a-zA-Z0-9]+")) { // check if there really is a tx hash
          tt.add(new Transi(aj[i].getSpentTxid()));
          if (w != root) {
            w.takeFromStore(aj[i].getValue() / 100000000);
          }
          tt.get(tt.size() - 1).addBitcoins(new Bitcoins(aj[i].getValue() / 100000000, false));
          if (tt.size() >= 1000) {
            break;
          }
        }
      }

      if (tt.size() < 1) {
        System.out.println("nothing to follow. exiting..");
        System.exit(0);
      }
      outTransactions.add(tt);
    } catch (NullPointerException e) {
      System.out.println(e.getMessage());
    }

  }

  private void loadWallets(Transi t) {
    String txHash = t.getHash();
    try {
      TransactionJSON tj = DataRetriever.getTransactionJSONObject(txHash);
      ArrayList<Wallet> w = new ArrayList<Wallet>();

      for (Output o : tj.getOutputs()) {
        if (o.getAddress().matches("[a-zA-Z0-9]+") && !o.getAddress().contains("false")) { // check if there really is an address
          w.add(new Wallet(o.getAddress()));
          t.takeFromStack(o.getValue() / 100000000);
          w.get(w.size() - 1).addToStore(o.getValue() / 100000000, false);
          if (w.size() >= 1000) {
            break;
          }
        }
      }
      wallets.add(w);
    } catch (NullPointerException e) {
      System.out.println(e.getMessage());
    }
  }

  private void flagAllCoins(int depth) {
    for (Transi t : outTransactions.get(depth)) {
      for (Bitcoins b : t.getStack()) {
        b.setFlagged();
      }
    }
  }

  public String getRootAddress() {
    return rootAddress;
  }

  public Wallet getRoot() {
    return root;
  }
}
